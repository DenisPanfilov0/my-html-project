<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Merge-Tetris Fusion Updated</title>
<style>
  html,body{height:100%;margin:0;background:#111;color:#eee;font-family:Arial}
  #game{display:block;margin:10px auto;background:#0b1220;border:4px solid #222;box-shadow:0 6px 30px rgba(0,0,0,0.7)}
  #ui{width:800px;margin:8px auto;text-align:center}
  button{padding:6px 12px;margin:4px;background:#222;border:0;color:#fff;border-radius:6px;cursor:pointer}
  #hud{position:absolute;top:10px;left:20px;color:#fff;font-size:16px;}
  #rainbowBox{position:absolute;top:10px;right:20px;display:flex;align-items:center;gap:8px;}
  #rainbowIcon{width:24px;height:24px;border-radius:50%;background:linear-gradient(45deg,red,orange,yellow,green,blue,indigo,violet);}
</style>
</head>
<body>
<div id="ui">
  <button id="reset">Сброс</button>
</div>
<canvas id="game" width="800" height="600"></canvas>
<div id="hud">Очки: <span id="score">0</span></div>
<div id="rainbowBox"><div id="rainbowIcon"></div><span id="rainbowCount">0</span></div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;
const groundY = H - 20;

let score = 0;
let rainbowCount = 0;
const scoreEl = document.getElementById('score');
const rainbowEl = document.getElementById('rainbowCount');

const baseRadius = 16;
const colorsByRank = {
  1: '#2ecc71', // green
  2: '#3498db', // blue
  3: '#e74c3c', // red
  4: '#f1c40f', // yellow
  5: '#8b5a2b', // brown
  6: 'rainbow'
};

function randInt(a, b) { return Math.floor(Math.random() * (b - a + 1)) + a; }
function dist(a, b) { let dx = a.x - b.x, dy = a.y - b.y; return Math.sqrt(dx * dx + dy * dy); }

class Ball {
  constructor(x, y, rank, vx = 0, vy = 0, locked = false) {
    this.x = x; this.y = y;
    this.vx = vx; this.vy = vy;
    this.rank = rank;
    this.locked = locked;
    this.r = baseRadius; // Fixed size
    this.id = Math.random().toString(36).slice(2, 9);
    this.isAnimatingToCounter = false;
    this.targetX = W - 40;
    this.targetY = 20;
  }
  color() { return colorsByRank[this.rank]; }
  step() {
    if (this.locked) return false;
    if (this.isAnimatingToCounter) {
      let dx = this.targetX - this.x;
      let dy = this.targetY - this.y;
      let distance = Math.sqrt(dx * dx + dy * dy);
      if (distance < 5) {
        return true; // Signal to remove
      }
      this.x += dx / 10;
      this.y += dy / 10;
      return false;
    }
    this.vy += 0.35;
    this.vx *= 0.98;
    this.vy *= 0.98;
    if (Math.abs(this.vx) < 0.01) this.vx = 0;
    if (Math.abs(this.vy) < 0.01 && this.y + this.r >= groundY) this.vy = 0;
    this.x += this.vx; this.y += this.vy;
    if (this.x - this.r < 0) { this.x = this.r; this.vx = Math.abs(this.vx) * 0.6; }
    if (this.x + this.r > W) { this.x = W - this.r; this.vx = -Math.abs(this.vx) * 0.6; }
    if (this.y + this.r > groundY) { 
      this.y = groundY - this.r; 
      this.vy = -Math.abs(this.vy) * 0.2;
      this.vx *= 0.95;
      if (Math.abs(this.vy) < 0.5) { this.vy = 0; this.locked = true; }
    }
    return false;
  }
  draw(ctx) {
    ctx.save();
    if (this.rank === 6) {
      let g = ctx.createLinearGradient(this.x - this.r, this.y - this.r, this.x + this.r, this.y + this.r);
      g.addColorStop(0, '#ff6b6b'); g.addColorStop(0.2, '#f7b801'); g.addColorStop(0.4, '#ffd166');
      g.addColorStop(0.6, '#06d6a0'); g.addColorStop(0.8, '#4cc9f0'); g.addColorStop(1, '#c77dff');
      ctx.fillStyle = g;
    } else ctx.fillStyle = this.color();
    ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2); ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.stroke();
    ctx.restore();
  }
}

let circles = [];
let activePiece = null;
let nextPiece = null;
const dropSpeed = 5;

const tetrominoes = [
  [{x: -1.5*32, y: 0}, {x: -0.5*32, y: 0}, {x: 0.5*32, y: 0}, {x: 1.5*32, y: 0}], // I
  [{x: -0.5*32, y: -0.5*32}, {x: -0.5*32, y: 0.5*32}, {x: 0.5*32, y: -0.5*32}, {x: 0.5*32, y: 0.5*32}], // O
  [{x: -1*32, y: 0}, {x: 0, y: 0}, {x: 1*32, y: 0}, {x: 0, y: -1*32}], // T
  [{x: -1*32, y: -1*32}, {x: -1*32, y: 0}, {x: 0, y: 0}, {x: 1*32, y: 0}], // J
  [{x: 1*32, y: -1*32}, {x: -1*32, y: 0}, {x: 0, y: 0}, {x: 1*32, y: 0}], // L
  [{x: -1*32, y: 0}, {x: 0, y: 0}, {x: 0, y: -1*32}, {x: 1*32, y: -1*32}], // S
  [{x: -1*32, y: -1*32}, {x: 0, y: -1*32}, {x: 0, y: 0}, {x: 1*32, y: 0}] // Z
];

function assignRanks(shape) {
  let ranks = [];
  for (let i = 0; i < shape.length; i++) {
    let rank = randInt(1, 3);
    let adjacentSame = false;
    if (i > 0 && rank === ranks[i-1]) adjacentSame = true;
    while (adjacentSame) {
      rank = randInt(1, 3);
      adjacentSame = (i > 0 && rank === ranks[i-1]);
    }
    ranks.push(rank);
  }
  return ranks;
}

function spawnPiece(isNext = false) {
  let def = tetrominoes[randInt(0, tetrominoes.length - 1)];
  let ranks = assignRanks(def);
  let balls = def.map((p, i) => new Ball(W / 2 + p.x, 50 + p.y, ranks[i], 0, 0, true));
  let piece = { balls: balls, released: false, centerX: W / 2 };
  if (isNext) {
    nextPiece = piece;
  } else {
    activePiece = piece;
  }
}

function drawDropHint() {
  if (activePiece && !activePiece.released) {
    let centerX = activePiece.centerX;
    ctx.save();
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(centerX, Math.max(...activePiece.balls.map(b => b.y + b.r)));
    ctx.lineTo(centerX, groundY);
    ctx.stroke();
    ctx.restore();
  }
}

canvas.addEventListener('mousemove', (e) => {
  if (activePiece && !activePiece.released) {
    let rect = canvas.getBoundingClientRect();
    let x = e.clientX - rect.left;
    let dx = x - activePiece.centerX;
    activePiece.centerX = x;
    for (let b of activePiece.balls) {
      b.x += dx;
    }
    let minX = Math.min(...activePiece.balls.map(b => b.x - b.r));
    let maxX = Math.max(...activePiece.balls.map(b => b.x + b.r));
    if (minX < 0) {
      let shift = -minX;
      for (let b of activePiece.balls) b.x += shift;
      activePiece.centerX += shift;
    } else if (maxX > W) {
      let shift = W - maxX;
      for (let b of activePiece.balls) b.x += shift;
      activePiece.centerX += shift;
    }
  }
});

canvas.addEventListener('click', () => {
  if (activePiece && !activePiece.released) {
    activePiece.released = true;
  }
});

document.getElementById('reset').onclick = () => { circles = []; activePiece = null; nextPiece = null; score = 0; rainbowCount = 0; scoreEl.textContent = 0; rainbowEl.textContent = 0; spawnPiece(); spawnPiece(true); };

function handleCollisions() {
  for (let i = 0; i < circles.length; i++) {
    for (let j = i + 1; j < circles.length; j++) {
      let A = circles[i], B = circles[j];
      if (A.isAnimatingToCounter || B.isAnimatingToCounter) continue;
      let d = dist(A, B), minD = A.r + B.r;
      if (d < minD && d > 0) {
        let overlap = minD - d;
        let nx = (B.x - A.x) / d, ny = (B.y - A.y) / d;
        // Position correction
        let correction = overlap / 2;
        if (!A.locked) { A.x -= nx * correction; A.y -= ny * correction; }
        if (!B.locked) { B.x += nx * correction; B.y += ny * correction; }
        // Velocity resolution
        let relVx = B.vx - A.vx;
        let relVy = B.vy - A.vy;
        let dot = relVx * nx + relVy * ny;
        if (dot < 0) {
          let restitution = 0.3; // Low for realism
          let impulse = - (1 + restitution) * dot / 2; // Equal mass
          if (!A.locked) {
            A.vx -= impulse * nx;
            A.vy -= impulse * ny;
          }
          if (!B.locked) {
            B.vx += impulse * nx;
            B.vy += impulse * ny;
          }
        }
      }
    }
  }
}

function mergeCheck() {
  for (let i = 0; i < circles.length; i++) {
    for (let j = i + 1; j < circles.length; j++) {
      let A = circles[i], B = circles[j];
      if (A.isAnimatingToCounter || B.isAnimatingToCounter) continue;
      if (A.rank === B.rank && A.rank < 6) {
        if (dist(A, B) < (A.r + B.r) * 1.01 && Math.abs(A.vx) < 1 && Math.abs(A.vy) < 1 && Math.abs(B.vx) < 1 && Math.abs(B.vy) < 1) {
          score += A.rank * 2;
          scoreEl.textContent = score;
          let nx = (A.x + B.x) / 2, ny = (A.y + B.y) / 2;
          let newRank = A.rank + 1;
          let NB = new Ball(nx, ny, newRank, (A.vx + B.vx) / 2, (A.vy + B.vy) / 2 - 1, false);
          circles = circles.filter(c => c.id !== A.id && c.id !== B.id);
          circles.push(NB);
          if (newRank === 6) {
            setTimeout(() => {
              NB.isAnimatingToCounter = true;
              NB.locked = false;
              NB.vx = 0;
              NB.vy = 0;
            }, 500);
          }
          return true;
        }
      }
    }
  }
  return false;
}

function checkPieceCollision() {
  for (let b of activePiece.balls) {
    if (b.y + b.r > groundY) return true;
    for (let c of circles) {
      if (c.isAnimatingToCounter) continue;
      if (dist(b, c) < b.r + c.r) return true;
    }
  }
  return false;
}

function scatterPiece() {
  for (let b of activePiece.balls) {
    b.locked = false;
    b.vx = randInt(-1, 1); // Even smaller horizontal
    b.vy = -2 + randInt(-1, 1); // Small bounce
  }
  circles.push(...activePiece.balls);
  activePiece = nextPiece;
  spawnPiece(true);
}

function step() {
  if (activePiece && activePiece.released) {
    for (let b of activePiece.balls) {
      b.y += dropSpeed;
    }
    if (checkPieceCollision()) {
      scatterPiece();
    }
  }
  circles = circles.filter(b => {
    return !b.step();
  });
  handleCollisions();
  while (mergeCheck());
  render();
  requestAnimationFrame(step);
}

function render() {
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = '#071021'; ctx.fillRect(0, 0, W, H);
  ctx.fillStyle = '#0d2233'; ctx.fillRect(0, groundY, W, H - groundY);
  drawDropHint();
  if (activePiece) { for (let b of activePiece.balls) b.draw(ctx); }
  for (let b of circles) b.draw(ctx);
}

// Initial spawn
spawnPiece();
spawnPiece(true);
step();
</script>
</body>
</html>
